# Standard API Patterns Reference

> Complete reference for REST API design, authentication, error handling, and request/response patterns in Apso-generated backends

---

## Table of Contents

1. [REST Endpoint Structure](#rest-endpoint-structure)
2. [Authentication Middleware](#authentication-middleware)
3. [Error Handling](#error-handling)
4. [Request/Response Patterns](#requestresponse-patterns)
5. [Common API Operations](#common-api-operations)
6. [Best Practices](#best-practices)
7. [Status Codes Reference](#status-codes-reference)

---

## REST Endpoint Structure

### Standard CRUD Endpoints

Apso generates standard REST endpoints for all entities:

```
GET    /api/{resource}              - List all (paginated)
POST   /api/{resource}              - Create
GET    /api/{resource}/{id}         - Get by ID
PATCH  /api/{resource}/{id}         - Update
DELETE /api/{resource}/{id}         - Delete
```

### Example: Projects Resource

```
GET    /api/projects                - List all projects
POST   /api/projects                - Create project
GET    /api/projects/{id}           - Get project by ID
PATCH  /api/projects/{id}           - Update project
DELETE /api/projects/{id}           - Delete project
```

### URL Structure Rules

1. **Resource names are lowercase plural:**
   ```
   ✅ /api/projects
   ✅ /api/organizations
   ✅ /api/users

   ❌ /api/Project (wrong case)
   ❌ /api/project (wrong plurality)
   ```

2. **IDs are always UUID v4:**
   ```
   GET /api/projects/550e8400-e29b-41d4-a716-446655440000
   ```

3. **Nested resources use logical hierarchy:**
   ```
   GET /api/organizations/{org_id}/projects
   GET /api/projects/{project_id}/tasks
   ```

---

## Authentication Middleware

### Bearer Token Authentication

All protected endpoints require Bearer token in Authorization header:

```
Authorization: Bearer <session_token>
```

### Implementation Pattern

**Backend - NestJS Guard:**

```typescript
// src/autogen/guards/auth.guard.ts (AUTO-GENERATED)
// NOTE: Guards are now auto-generated by Apso CLI in src/autogen/guards/
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { verifyAuth } from 'better-auth/client';

@Injectable()
export class AuthGuard implements CanActivate {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const authHeader = request.headers.authorization;

    if (!authHeader) {
      throw new UnauthorizedException('Missing Authorization header');
    }

    const token = authHeader.replace('Bearer ', '');

    try {
      // Verify token with Better Auth
      const session = await verifySession(token);

      if (!session) {
        throw new UnauthorizedException('Invalid or expired token');
      }

      // Attach user to request context
      request.user = session.user;
      request.session = session;

      return true;
    } catch (error) {
      throw new UnauthorizedException('Invalid token');
    }
  }
}

// src/decorators/current-user.decorator.ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);
```

**Usage in Controllers:**

```typescript
// src/autogen/Project/Project.controller.ts
import { UseGuards } from '@nestjs/common';

@Controller('projects')
@UseGuards(AuthGuard)
export class ProjectController {
  @Get()
  async list(@CurrentUser() user: User) {
    // user is automatically injected
    return this.projectService.findByUserId(user.id);
  }

  @Post()
  async create(
    @CurrentUser() user: User,
    @Body() createProjectDto: CreateProjectDto,
  ) {
    return this.projectService.create({
      ...createProjectDto,
      user_id: user.id,
    });
  }

  @Get(':id')
  async getById(
    @Param('id') id: string,
    @CurrentUser() user: User,
  ) {
    return this.projectService.findById(id, user.id);
  }

  @Patch(':id')
  async update(
    @Param('id') id: string,
    @CurrentUser() user: User,
    @Body() updateProjectDto: UpdateProjectDto,
  ) {
    return this.projectService.update(id, updateProjectDto, user.id);
  }

  @Delete(':id')
  async delete(
    @Param('id') id: string,
    @CurrentUser() user: User,
  ) {
    return this.projectService.delete(id, user.id);
  }
}
```

### Token Validation Flow

```
Client sends request
    ↓
Authorization header checked
    ↓
Token extracted from "Bearer {token}"
    ↓
Token verified with Better Auth
    ↓
Session & user attached to request
    ↓
Handler executes with user context
```

---

## Error Handling

### Standard Error Response Format

All errors return consistent JSON structure:

```typescript
{
  statusCode: number;
  message: string;
  error: string;         // Error type (e.g., "BadRequest")
  timestamp: string;     // ISO 8601 timestamp
  path: string;          // Request path
  details?: any;         // Additional error context
}
```

### Example Error Responses

**400 Bad Request (Validation):**
```json
{
  "statusCode": 400,
  "message": "Invalid request body",
  "error": "BadRequestException",
  "details": {
    "name": "name must be a string",
    "slug": "slug must match pattern ^[a-z0-9-]+$"
  },
  "timestamp": "2025-01-18T10:30:00Z",
  "path": "/api/projects"
}
```

**401 Unauthorized (Auth):**
```json
{
  "statusCode": 401,
  "message": "Missing or invalid authentication token",
  "error": "UnauthorizedException",
  "timestamp": "2025-01-18T10:30:00Z",
  "path": "/api/projects"
}
```

**403 Forbidden (Permission):**
```json
{
  "statusCode": 403,
  "message": "You don't have permission to access this resource",
  "error": "ForbiddenException",
  "details": {
    "reason": "Not a member of this organization"
  },
  "timestamp": "2025-01-18T10:30:00Z",
  "path": "/api/organizations/123/projects"
}
```

**404 Not Found:**
```json
{
  "statusCode": 404,
  "message": "Project not found",
  "error": "NotFoundException",
  "timestamp": "2025-01-18T10:30:00Z",
  "path": "/api/projects/invalid-id"
}
```

**409 Conflict (Duplicate):**
```json
{
  "statusCode": 409,
  "message": "Project with slug 'my-project' already exists",
  "error": "ConflictException",
  "timestamp": "2025-01-18T10:30:00Z",
  "path": "/api/projects"
}
```

**422 Unprocessable Entity:**
```json
{
  "statusCode": 422,
  "message": "Cannot delete project with active tasks",
  "error": "UnprocessableEntityException",
  "details": {
    "activeTaskCount": 5
  },
  "timestamp": "2025-01-18T10:30:00Z",
  "path": "/api/projects/123"
}
```

**500 Internal Server Error:**
```json
{
  "statusCode": 500,
  "message": "An unexpected error occurred",
  "error": "InternalServerErrorException",
  "timestamp": "2025-01-18T10:30:00Z",
  "path": "/api/projects"
}
```

### Error Handling in Controllers

```typescript
// src/autogen/Project/Project.controller.ts
import {
  BadRequestException,
  ForbiddenException,
  NotFoundException,
  ConflictException,
} from '@nestjs/common';

@Controller('projects')
export class ProjectController {
  @Get(':id')
  async getById(
    @Param('id') id: string,
    @CurrentUser() user: User,
  ) {
    // Validate UUID format
    if (!isValidUUID(id)) {
      throw new BadRequestException('Invalid project ID format');
    }

    const project = await this.projectService.findById(id);

    // Check existence
    if (!project) {
      throw new NotFoundException(`Project with ID ${id} not found`);
    }

    // Check permission
    if (project.user_id !== user.id) {
      throw new ForbiddenException('You cannot access this project');
    }

    return project;
  }

  @Post()
  async create(
    @Body() createProjectDto: CreateProjectDto,
    @CurrentUser() user: User,
  ) {
    // Validate input
    const validation = validateCreateProjectDto(createProjectDto);
    if (!validation.valid) {
      throw new BadRequestException(validation.errors);
    }

    // Check for duplicate
    const existing = await this.projectService.findBySlug(createProjectDto.slug);
    if (existing) {
      throw new ConflictException(
        `Project with slug '${createProjectDto.slug}' already exists`,
      );
    }

    // Create
    return this.projectService.create({
      ...createProjectDto,
      user_id: user.id,
    });
  }

  @Delete(':id')
  async delete(
    @Param('id') id: string,
    @CurrentUser() user: User,
  ) {
    const project = await this.projectService.findById(id);

    if (!project) {
      throw new NotFoundException(`Project not found`);
    }

    if (project.user_id !== user.id) {
      throw new ForbiddenException('Cannot delete other users projects');
    }

    // Check for dependent data
    const taskCount = await this.taskService.countByProjectId(id);
    if (taskCount > 0) {
      throw new UnprocessableEntityException(
        `Cannot delete project with ${taskCount} active tasks`,
      );
    }

    return this.projectService.delete(id);
  }
}
```

### Global Exception Filter

```typescript
// src/filters/http-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(HttpExceptionFilter.name);

  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();
    const status = exception.getStatus();
    const exceptionResponse = exception.getResponse();

    // Log error
    this.logger.error(
      `${request.method} ${request.url} - ${status}`,
      exception.stack,
    );

    const body: any = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
    };

    if (typeof exceptionResponse === 'object') {
      Object.assign(body, exceptionResponse);
    } else {
      body.message = exceptionResponse;
      body.error = exception.name;
    }

    response.status(status).json(body);
  }
}
```

---

## Request/Response Patterns

### Standard Request Format

All POST/PATCH requests use JSON body:

```typescript
{
  "field1": "value",
  "field2": "value",
  "nested": {
    "field": "value"
  }
}
```

### Standard Response Format

All responses return JSON:

**Single Resource:**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "My Project",
  "slug": "my-project",
  "user_id": "550e8400-e29b-41d4-a716-446655440001",
  "created_at": "2025-01-18T10:30:00Z",
  "updated_at": "2025-01-18T10:30:00Z"
}
```

**Collection (Paginated):**
```json
{
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "Project 1",
      "slug": "project-1",
      "created_at": "2025-01-18T10:30:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440001",
      "name": "Project 2",
      "slug": "project-2",
      "created_at": "2025-01-18T10:31:00Z"
    }
  ],
  "pagination": {
    "page": 1,
    "pageSize": 20,
    "total": 42,
    "totalPages": 3,
    "hasNextPage": true,
    "hasPreviousPage": false
  }
}
```

### Pagination Query Parameters

```
GET /api/projects?page=1&pageSize=20&sort=created_at&order=desc
```

**Supported Query Parameters:**
- `page` (default: 1) - Page number
- `pageSize` (default: 20, max: 100) - Items per page
- `sort` - Field to sort by
- `order` - Sort direction (asc/desc)
- `search` - Text search
- `filter[field]` - Filter by field value

**Examples:**

```
GET /api/projects?page=1&pageSize=50
GET /api/projects?sort=name&order=asc
GET /api/projects?sort=created_at&order=desc
GET /api/projects?search=backend
GET /api/projects?filter[user_id]=550e8400-e29b-41d4-a716-446655440000
GET /api/projects?page=1&pageSize=20&sort=created_at&order=desc&filter[status]=active
```

### Filtering Pattern

```typescript
// Multi-field filtering
GET /api/tasks?filter[project_id]=123&filter[status]=pending&filter[assigned_to]=user-456

// Complex filters
GET /api/tasks?filter[created_at_gte]=2025-01-01&filter[created_at_lte]=2025-01-31
```

**Supported Filter Operators:**
- `field=value` - Exact match
- `field_ne=value` - Not equal
- `field_gt=value` - Greater than
- `field_gte=value` - Greater than or equal
- `field_lt=value` - Less than
- `field_lte=value` - Less than or equal
- `field_in=val1,val2,val3` - In array
- `field_nin=val1,val2,val3` - Not in array
- `field_like=%text%` - SQL LIKE

---

## Common API Operations

### 1. GET - List Resources

**Request:**
```bash
GET /api/projects?page=1&pageSize=20&sort=created_at&order=desc
Authorization: Bearer {token}
```

**Response (200 OK):**
```json
{
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "My Project",
      "slug": "my-project",
      "created_at": "2025-01-18T10:30:00Z"
    }
  ],
  "pagination": {
    "page": 1,
    "pageSize": 20,
    "total": 42,
    "totalPages": 3
  }
}
```

**Error (401 Unauthorized):**
```json
{
  "statusCode": 401,
  "message": "Missing or invalid token",
  "error": "UnauthorizedException"
}
```

### 2. POST - Create Resource

**Request:**
```bash
POST /api/projects
Authorization: Bearer {token}
Content-Type: application/json

{
  "name": "My New Project",
  "slug": "my-new-project",
  "description": "A description"
}
```

**Response (201 Created):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "My New Project",
  "slug": "my-new-project",
  "description": "A description",
  "user_id": "550e8400-e29b-41d4-a716-446655440001",
  "created_at": "2025-01-18T10:30:00Z",
  "updated_at": "2025-01-18T10:30:00Z"
}
```

**Error (400 Bad Request):**
```json
{
  "statusCode": 400,
  "message": "Validation failed",
  "error": "BadRequestException",
  "details": {
    "name": "name is required",
    "slug": "slug must match pattern"
  }
}
```

### 3. GET - Get Single Resource

**Request:**
```bash
GET /api/projects/{id}
Authorization: Bearer {token}
```

**Response (200 OK):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "My Project",
  "slug": "my-project",
  "user_id": "550e8400-e29b-41d4-a716-446655440001",
  "created_at": "2025-01-18T10:30:00Z"
}
```

**Error (404 Not Found):**
```json
{
  "statusCode": 404,
  "message": "Project not found",
  "error": "NotFoundException"
}
```

### 4. PATCH - Update Resource

**Request:**
```bash
PATCH /api/projects/{id}
Authorization: Bearer {token}
Content-Type: application/json

{
  "name": "Updated Project Name"
}
```

**Response (200 OK):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "Updated Project Name",
  "slug": "my-project",
  "user_id": "550e8400-e29b-41d4-a716-446655440001",
  "created_at": "2025-01-18T10:30:00Z",
  "updated_at": "2025-01-18T10:35:00Z"
}
```

### 5. DELETE - Delete Resource

**Request:**
```bash
DELETE /api/projects/{id}
Authorization: Bearer {token}
```

**Response (204 No Content):**
```
(empty body)
```

**Error (409 Conflict):**
```json
{
  "statusCode": 409,
  "message": "Cannot delete project with active tasks",
  "error": "ConflictException"
}
```

---

## Best Practices

### 1. Always Verify Ownership

**Pattern:**
```typescript
async getProject(id: string, userId: string) {
  const project = await this.projectRepository.findById(id);

  if (!project) {
    throw new NotFoundException('Project not found');
  }

  // Verify user owns project
  if (project.user_id !== userId) {
    throw new ForbiddenException('You cannot access this project');
  }

  return project;
}
```

### 2. Use Consistent Timestamps

**Pattern:**
```typescript
export interface ApiResponse {
  id: string;
  name: string;
  created_at: string;  // ISO 8601 format
  updated_at: string;  // ISO 8601 format
}

// Always return timestamps in ISO 8601
new Date().toISOString()  // ✅ "2025-01-18T10:30:00Z"
Date.now()                // ❌ 1705580400000
```

### 3. Implement Soft Deletes

**Database Field:**
```json
{
  "name": "deleted_at",
  "type": "timestamp",
  "nullable": true,
  "comment": "Soft delete timestamp"
}
```

**Query Pattern:**
```typescript
// Exclude soft-deleted records
async findActive() {
  return this.repository.find({
    where: { deleted_at: IsNull() }
  });
}

// Soft delete
async delete(id: string) {
  return this.repository.update(id, {
    deleted_at: new Date()
  });
}
```

### 4. Use DTOs for Request/Response

**Pattern:**
```typescript
// src/autogen/Project/dtos/CreateProjectDto.ts
export class CreateProjectDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  @Matches(/^[a-z0-9-]+$/)
  slug: string;

  @IsOptional()
  @IsString()
  description?: string;
}

// src/autogen/Project/dtos/ProjectResponseDto.ts
export class ProjectResponseDto {
  id: string;
  name: string;
  slug: string;
  description: string;
  user_id: string;
  created_at: string;
  updated_at: string;
}
```

### 5. Validate All Inputs

**Pattern:**
```typescript
@Post()
@UsePipes(new ValidationPipe({
  whitelist: true,
  forbidNonWhitelisted: true,
  transform: true,
}))
async create(@Body() createProjectDto: CreateProjectDto) {
  // Validation happens automatically
  // Extra fields rejected
  // Types coerced
  return this.projectService.create(createProjectDto);
}
```

### 6. Rate Limiting

**Pattern:**
```typescript
import { ThrottlerGuard, Throttle } from '@nestjs/throttler';

@UseGuards(ThrottlerGuard)
@Throttle({ default: { limit: 10, ttl: 60000 } })  // 10 requests per minute
@Get()
async list() {
  // ...
}
```

### 7. Logging

**Pattern:**
```typescript
private readonly logger = new Logger(ProjectController.name);

@Get(':id')
async getById(@Param('id') id: string) {
  this.logger.debug(`Fetching project: ${id}`);

  try {
    const project = await this.projectService.findById(id);
    this.logger.log(`Project fetched: ${id}`);
    return project;
  } catch (error) {
    this.logger.error(`Failed to fetch project: ${id}`, error);
    throw error;
  }
}
```

---

## Status Codes Reference

| Code | Meaning | When to Use |
|------|---------|------------|
| **200** | OK | Successful GET, PATCH, DELETE |
| **201** | Created | Successful POST |
| **204** | No Content | Successful DELETE (no response body) |
| **400** | Bad Request | Invalid request format or validation failure |
| **401** | Unauthorized | Missing or invalid authentication |
| **403** | Forbidden | Authenticated but lacks permission |
| **404** | Not Found | Resource doesn't exist |
| **409** | Conflict | Duplicate resource or constraint violation |
| **422** | Unprocessable Entity | Validation passed but can't process (e.g., dependent data) |
| **429** | Too Many Requests | Rate limit exceeded |
| **500** | Server Error | Unexpected error |
| **503** | Service Unavailable | Service temporarily down |

---

## OpenAPI Documentation

Apso automatically generates OpenAPI 3.0 documentation:

```
GET /api/docs                - Swagger UI
GET /api-json               - OpenAPI JSON schema
GET /api-yaml               - OpenAPI YAML schema
```

**Access in development:**
```
http://localhost:3001/api/docs
```

---

**Last Updated:** 2025-01-18
**Version:** 1.0
**Status:** Complete Reference
