---
description: Contribution standards for full-stack application development
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.js"
  - "**/*.jsx"
alwaysApply: true
---

# Rule: Contribution Standards

This rule defines coding standards, best practices, and technical expectations for contributing to full-stack applications. These principles apply regardless of specific technology choices.

---

## Core Principles

### 1. S.O.L.I.D. Principles

**Single Responsibility**
Each module, class, or function should have one clear purpose.

```typescript
// ❌ Bad: Multiple responsibilities
class UserManager {
  async createUser(data) { }
  async sendEmail(to, body) { }
  async logActivity(action) { }
  async generateReport() { }
}

// ✅ Good: Single responsibility
class UserService {
  async createUser(data: CreateUserDto): Promise<User> { }
}

class EmailService {
  async sendEmail(to: string, body: string): Promise<void> { }
}

class AuditLogger {
  async logActivity(action: string): Promise<void> { }
}
```

**Open/Closed**
Open for extension, closed for modification.

```typescript
// ✅ Good: Use interfaces and dependency injection
interface PaymentProcessor {
  processPayment(amount: number): Promise<PaymentResult>;
}

class StripePaymentProcessor implements PaymentProcessor {
  async processPayment(amount: number): Promise<PaymentResult> {
    // Stripe-specific logic
  }
}

class PayPalPaymentProcessor implements PaymentProcessor {
  async processPayment(amount: number): Promise<PaymentResult> {
    // PayPal-specific logic
  }
}

class CheckoutService {
  constructor(private paymentProcessor: PaymentProcessor) {}

  async checkout(order: Order): Promise<void> {
    await this.paymentProcessor.processPayment(order.total);
  }
}
```

**Liskov Substitution**
Derived classes must be substitutable for their base classes.

**Interface Segregation**
Clients shouldn't depend on interfaces they don't use.

**Dependency Inversion**
Depend on abstractions, not concretions.

### 2. Type Safety

Use strict TypeScript configuration and comprehensive type definitions.

```typescript
// ✅ Enable strict mode in tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "strictNullChecks": true,
    "noImplicitAny": true,
    "strictFunctionTypes": true
  }
}

// ✅ Good: Explicit types
interface User {
  id: string;
  email: string;
  name: string | null;
  createdAt: Date;
}

async function getUser(id: string): Promise<User | null> {
  const user = await db.user.findUnique({ where: { id } });
  return user;
}

// ❌ Bad: Implicit any
async function getUser(id) {
  return await db.user.findUnique({ where: { id } });
}
```

### 3. Separation of Concerns

Organize code by responsibility and layer.

```typescript
// ✅ Good: Clear layer separation

// Presentation Layer - controller.ts
@Controller('users')
export class UserController {
  constructor(private userService: UserService) {}

  @Post()
  async create(@Body() dto: CreateUserDto) {
    return this.userService.createUser(dto);
  }
}

// Application Layer - service.ts
@Injectable()
export class UserService {
  constructor(
    private userRepo: UserRepository,
    private emailService: EmailService
  ) {}

  async createUser(dto: CreateUserDto): Promise<User> {
    const user = await this.userRepo.create(dto);
    await this.emailService.sendWelcome(user.email);
    return user;
  }
}

// Infrastructure Layer - repository.ts
@Injectable()
export class UserRepository {
  constructor(private db: Database) {}

  async create(data: CreateUserDto): Promise<User> {
    return this.db.user.create({ data });
  }
}
```

---

## TypeScript Best Practices

### Strict Null Checking

```typescript
// ✅ Good: Handle null/undefined explicitly
function getUserName(user: User | null): string {
  if (!user) {
    return 'Guest';
  }
  return user.name ?? 'Unknown';
}

// ✅ Good: Use optional chaining
const email = user?.profile?.email?.toLowerCase() ?? 'no-email';

// ❌ Bad: Unsafe access
const email = user.profile.email.toLowerCase();
```

### Type Guards

```typescript
// ✅ Good: Custom type guards
interface Dog {
  type: 'dog';
  bark(): void;
}

interface Cat {
  type: 'cat';
  meow(): void;
}

type Pet = Dog | Cat;

function isDog(pet: Pet): pet is Dog {
  return pet.type === 'dog';
}

function makeSound(pet: Pet) {
  if (isDog(pet)) {
    pet.bark(); // TypeScript knows pet is Dog
  } else {
    pet.meow(); // TypeScript knows pet is Cat
  }
}
```

### Discriminated Unions

```typescript
// ✅ Good: Type-safe result handling
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

function processResult<T>(result: Result<T>): T {
  if (result.success) {
    return result.data; // TypeScript knows data exists
  } else {
    throw result.error; // TypeScript knows error exists
  }
}
```

### Generic Constraints

```typescript
// ✅ Good: Constrained generics
interface HasId {
  id: string;
}

function findById<T extends HasId>(items: T[], id: string): T | undefined {
  return items.find(item => item.id === id);
}

// ✅ Good: Multiple constraints
function merge<T extends object, U extends object>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}
```

### Utility Types

```typescript
// ✅ Good: Use built-in utility types
interface User {
  id: string;
  email: string;
  name: string;
  password: string;
}

// Omit sensitive fields
type PublicUser = Omit<User, 'password'>;

// Make all fields optional
type PartialUser = Partial<User>;

// Make all fields required
type RequiredUser = Required<User>;

// Pick specific fields
type UserCredentials = Pick<User, 'email' | 'password'>;

// Make fields readonly
type ImmutableUser = Readonly<User>;
```

### Async/Await Patterns

```typescript
// ✅ Good: Proper error handling
async function fetchUserData(id: string): Promise<User> {
  try {
    const user = await db.user.findUnique({ where: { id } });
    if (!user) {
      throw new NotFoundError(`User ${id} not found`);
    }
    return user;
  } catch (error) {
    if (error instanceof NotFoundError) {
      throw error;
    }
    throw new DatabaseError('Failed to fetch user', { cause: error });
  }
}

// ✅ Good: Parallel operations
async function getUserWithPosts(userId: string) {
  const [user, posts] = await Promise.all([
    db.user.findUnique({ where: { id: userId } }),
    db.post.findMany({ where: { userId } })
  ]);

  return { user, posts };
}

// ❌ Bad: Sequential when parallel is possible
async function getUserWithPosts(userId: string) {
  const user = await db.user.findUnique({ where: { id: userId } });
  const posts = await db.post.findMany({ where: { userId } });
  return { user, posts };
}
```

---

## API Design Standards

### RESTful Conventions

**Resource Naming:**
- Use plural nouns: `/users`, `/products`, `/orders`
- Use kebab-case for multi-word: `/order-items`, `/user-preferences`
- Nest resources logically: `/users/:id/posts`, `/workspaces/:id/members`

**HTTP Methods:**
```typescript
// GET - Retrieve resources
GET /users           // List all users
GET /users/:id       // Get specific user

// POST - Create new resource
POST /users          // Create user

// PUT - Replace entire resource
PUT /users/:id       // Replace user

// PATCH - Partial update
PATCH /users/:id     // Update user fields

// DELETE - Remove resource
DELETE /users/:id    // Delete user
```

### Response Formats

**Success Response:**
```typescript
// ✅ Good: Consistent success format
interface ApiResponse<T> {
  success: true;
  data: T;
  meta?: {
    page?: number;
    limit?: number;
    total?: number;
  };
}

// Example
{
  "success": true,
  "data": {
    "id": "user-123",
    "email": "user@example.com",
    "name": "John Doe"
  }
}

// List with pagination
{
  "success": true,
  "data": [...],
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 150
  }
}
```

**Error Response:**
```typescript
// ✅ Good: Consistent error format
interface ApiError {
  success: false;
  error: {
    code: string;
    message: string;
    details?: Record<string, unknown>;
    timestamp: string;
    path: string;
  };
}

// Example
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input data",
    "details": {
      "email": "Must be a valid email address",
      "password": "Must be at least 8 characters"
    },
    "timestamp": "2025-01-11T10:30:00Z",
    "path": "/api/users"
  }
}
```

### HTTP Status Codes

**Use appropriate status codes:**
```typescript
// Success
200 OK          // Successful GET, PUT, PATCH, DELETE
201 Created     // Successful POST
204 No Content  // Successful DELETE with no response body

// Client Errors
400 Bad Request           // Invalid input data
401 Unauthorized          // Missing or invalid authentication
403 Forbidden             // Authenticated but no permission
404 Not Found             // Resource doesn't exist
409 Conflict              // Resource conflict (duplicate email)
422 Unprocessable Entity  // Validation errors
429 Too Many Requests     // Rate limit exceeded

// Server Errors
500 Internal Server Error // Unexpected server error
502 Bad Gateway          // Upstream service error
503 Service Unavailable  // Temporary unavailability
```

### Error Handling

```typescript
// ✅ Good: Custom error classes
export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number,
    public code: string,
    public details?: Record<string, unknown>
  ) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: Record<string, unknown>) {
    super(message, 422, 'VALIDATION_ERROR', details);
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string, id: string) {
    super(`${resource} with id ${id} not found`, 404, 'NOT_FOUND');
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = 'Unauthorized') {
    super(message, 401, 'UNAUTHORIZED');
  }
}

// Usage in service
async function getUserById(id: string): Promise<User> {
  const user = await db.user.findUnique({ where: { id } });
  if (!user) {
    throw new NotFoundError('User', id);
  }
  return user;
}

// Global error handler (Express example)
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      success: false,
      error: {
        code: err.code,
        message: err.message,
        details: err.details,
        timestamp: new Date().toISOString(),
        path: req.path
      }
    });
  }

  // Unexpected errors
  console.error('Unexpected error:', err);
  return res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_ERROR',
      message: 'An unexpected error occurred',
      timestamp: new Date().toISOString(),
      path: req.path
    }
  });
});
```

### Input Validation

```typescript
// ✅ Good: Schema-based validation with Zod
import { z } from 'zod';

const CreateUserSchema = z.object({
  email: z.string().email('Must be a valid email'),
  name: z.string().min(2, 'Name must be at least 2 characters'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain uppercase letter')
    .regex(/[0-9]/, 'Password must contain number'),
  role: z.enum(['user', 'admin']).default('user')
});

type CreateUserDto = z.infer<typeof CreateUserSchema>;

// Validate in controller
async function createUser(req: Request, res: Response) {
  try {
    const data = CreateUserSchema.parse(req.body);
    const user = await userService.createUser(data);
    return res.status(201).json({ success: true, data: user });
  } catch (error) {
    if (error instanceof z.ZodError) {
      const details = error.errors.reduce((acc, err) => {
        acc[err.path.join('.')] = err.message;
        return acc;
      }, {} as Record<string, string>);

      throw new ValidationError('Invalid input data', details);
    }
    throw error;
  }
}
```

### API Versioning

```typescript
// ✅ Good: URL-based versioning
app.use('/api/v1/users', v1UsersRouter);
app.use('/api/v2/users', v2UsersRouter);

// ✅ Good: Header-based versioning
app.use((req, res, next) => {
  const version = req.headers['api-version'] || 'v1';
  req.apiVersion = version;
  next();
});
```

---

## Database Guidelines

### Query Optimization

```typescript
// ✅ Good: Select only needed fields
const user = await db.user.findUnique({
  where: { id },
  select: {
    id: true,
    email: true,
    name: true
    // Don't select password or sensitive data unnecessarily
  }
});

// ✅ Good: Use indexes for common queries
// In migration or entity definition
@Index(['email'])
@Index(['workspaceId', 'email']) // Composite index
@Entity()
export class User {
  @Column({ unique: true })
  email: string;

  @Column()
  @Index()
  workspaceId: string;
}

// ✅ Good: Batch operations
// Instead of N queries
for (const user of users) {
  await db.post.create({ data: { userId: user.id } });
}

// Do 1 query
await db.post.createMany({
  data: users.map(user => ({ userId: user.id }))
});
```

### Multi-Tenancy Isolation

```typescript
// ✅ CRITICAL: Always filter by workspace/tenant
async function getUsersByWorkspace(workspaceId: string): Promise<User[]> {
  return db.user.findMany({
    where: {
      workspaceId: workspaceId, // REQUIRED for multi-tenancy
      deletedAt: null
    }
  });
}

// ✅ Good: Use middleware for automatic tenant filtering
app.use(async (req, res, next) => {
  const workspaceId = req.user?.workspaceId;
  if (!workspaceId) {
    throw new UnauthorizedError('No workspace context');
  }
  req.workspaceId = workspaceId;
  next();
});

// ❌ DANGEROUS: Missing tenant filter
async function getAllUsers(): Promise<User[]> {
  return db.user.findMany(); // Exposes all tenants' data!
}
```

### Transactions

```typescript
// ✅ Good: Use transactions for multi-step operations
async function transferCredits(
  fromUserId: string,
  toUserId: string,
  amount: number
): Promise<void> {
  await db.$transaction(async (tx) => {
    // Debit from sender
    await tx.user.update({
      where: { id: fromUserId },
      data: { credits: { decrement: amount } }
    });

    // Credit to recipient
    await tx.user.update({
      where: { id: toUserId },
      data: { credits: { increment: amount } }
    });

    // Log transaction
    await tx.transaction.create({
      data: {
        fromUserId,
        toUserId,
        amount,
        type: 'TRANSFER'
      }
    });
  });
}
```

---

## Testing Standards

### Unit Testing

```typescript
// ✅ Good: Test business logic in isolation
describe('UserService', () => {
  let service: UserService;
  let mockRepository: jest.Mocked<UserRepository>;
  let mockEmailService: jest.Mocked<EmailService>;

  beforeEach(() => {
    mockRepository = {
      create: jest.fn(),
      findByEmail: jest.fn(),
    } as any;

    mockEmailService = {
      sendWelcome: jest.fn(),
    } as any;

    service = new UserService(mockRepository, mockEmailService);
  });

  describe('createUser', () => {
    it('should create user and send welcome email', async () => {
      const dto = { email: 'test@example.com', name: 'Test' };
      const user = { id: '1', ...dto };

      mockRepository.create.mockResolvedValue(user);

      const result = await service.createUser(dto);

      expect(result).toEqual(user);
      expect(mockRepository.create).toHaveBeenCalledWith(dto);
      expect(mockEmailService.sendWelcome).toHaveBeenCalledWith(user.email);
    });

    it('should throw error if email already exists', async () => {
      mockRepository.findByEmail.mockResolvedValue({ id: '1' } as User);

      await expect(
        service.createUser({ email: 'existing@example.com', name: 'Test' })
      ).rejects.toThrow('Email already exists');
    });
  });
});
```

### Integration Testing

See `testing-guide.mdc` for comprehensive integration testing patterns.

---

## Code Quality

### Code Reviews

**Before requesting review:**
- [ ] All tests pass
- [ ] No linting errors
- [ ] Code is self-documenting with clear names
- [ ] Complex logic has comments explaining "why"
- [ ] No console.log or debug code
- [ ] Security vulnerabilities checked
- [ ] Performance considerations addressed

### Commits

**Use conventional commits:**
```bash
feat: add user profile page
fix: resolve null pointer in auth service
refactor: simplify payment processing logic
test: add integration tests for order flow
docs: update API documentation
chore: upgrade dependencies
```

**Commit guidelines:**
- Make atomic commits (one logical change per commit)
- Write clear, descriptive commit messages
- Reference issue/task IDs when applicable
- Commit frequently (don't wait for complete features)

### Documentation

**Code Comments:**
```typescript
// ✅ Good: Explain "why", not "what"
// We cache user permissions for 5 minutes to reduce database load
// during high-traffic periods. This is acceptable because permission
// changes are rare and eventual consistency is tolerable.
const permissions = await cache.get(`user:${userId}:permissions`, {
  ttl: 300,
  fetchFn: () => db.getUserPermissions(userId)
});

// ❌ Bad: States the obvious
// Get user permissions
const permissions = await getUserPermissions(userId);
```

**JSDoc for Public APIs:**
```typescript
/**
 * Creates a new user account and sends a welcome email.
 *
 * @param dto - User creation data including email, name, and password
 * @param workspaceId - The workspace this user belongs to
 * @returns The created user (without password)
 * @throws {ValidationError} If input data is invalid
 * @throws {ConflictError} If email already exists
 *
 * @example
 * ```typescript
 * const user = await createUser({
 *   email: 'user@example.com',
 *   name: 'John Doe',
 *   password: 'SecurePass123!'
 * }, 'workspace-123');
 * ```
 */
export async function createUser(
  dto: CreateUserDto,
  workspaceId: string
): Promise<PublicUser> {
  // Implementation
}
```

---

## Performance Considerations

### Frontend Performance

```typescript
// ✅ Good: Lazy load components
const Dashboard = lazy(() => import('./Dashboard'));

// ✅ Good: Memoize expensive calculations
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(data);
}, [data]);

// ✅ Good: Debounce input handlers
const debouncedSearch = useDebouncedCallback(
  (searchTerm) => fetchResults(searchTerm),
  500
);
```

### Backend Performance

```typescript
// ✅ Good: Use caching for expensive operations
async function getPopularPosts(): Promise<Post[]> {
  const cached = await cache.get('popular-posts');
  if (cached) return cached;

  const posts = await db.post.findMany({
    where: { published: true },
    orderBy: { views: 'desc' },
    take: 10
  });

  await cache.set('popular-posts', posts, { ttl: 3600 });
  return posts;
}

// ✅ Good: Paginate large result sets
async function getUsers(page: number = 1, limit: number = 20) {
  const offset = (page - 1) * limit;

  const [users, total] = await Promise.all([
    db.user.findMany({
      skip: offset,
      take: limit
    }),
    db.user.count()
  ]);

  return {
    data: users,
    meta: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit)
    }
  };
}
```

---

## Security Considerations

See `security-standards.mdc` for comprehensive security guidelines.

**Quick Checklist:**
- [ ] All inputs validated
- [ ] Authentication required for protected routes
- [ ] Authorization checks for all operations
- [ ] SQL injection prevented (use parameterized queries)
- [ ] XSS prevented (sanitize outputs)
- [ ] CSRF protection enabled
- [ ] Rate limiting configured
- [ ] Secrets never committed to git
- [ ] Multi-tenancy isolation enforced
- [ ] Audit logging for sensitive operations

---

## Related Documentation

- **Code Structure:** `.devenv/rules/code-structure.mdc`
- **Security:** `.devenv/rules/security-standards.mdc`
- **Testing:** `.devenv/rules/testing-guide.mdc`
- **Task Management:** `.devenv/rules/process-task-list.mdc`
- **Local Development:** `.devenv/rules/local-development.mdc`

---

**Version:** 2.0
**Last Updated:** 2025-01-11
**Status:** Production-ready, technology-agnostic standards
