---
alwaysApply: true
description: Code organization principles and layer separation guidelines
version: 2.0
globs:
  - "**/*"
---

# Rule: Code Structure & Directory Conventions

This rule establishes principles for organizing code in modern full-stack applications using layered architecture, S.O.L.I.D. principles, and clear separation of concerns. It ensures contributors and agents place code in predictable, modular locations.

---

## Core Principles

### 1. Separation of Concerns
Code should be organized by functional domain and responsibility, not by file type.

**Good Examples:**
- Frontend UI components separate from backend API logic
- Business logic separate from infrastructure configuration
- Shared utilities separate from application-specific code
- Generated code separate from custom code

**Bad Examples:**
- Mixing frontend and backend code in same directories
- Combining business logic with infrastructure setup
- Storing documentation alongside source code
- Editing auto-generated files

### 2. Layer Boundaries
Each layer should have clear responsibilities and dependencies should flow in one direction.

**Common Layers:**
- **Presentation Layer** - UI components, pages, client-side logic
- **Application Layer** - API endpoints, request handlers, business workflows
- **Domain Layer** - Business logic, domain models, use cases
- **Infrastructure Layer** - Database access, external services, file storage
- **Shared Layer** - Common utilities, types, constants used across layers

### 3. Predictable Organization
Similar types of code should be organized consistently across the codebase.

---

## ğŸ¯ Code Placement Decision Tree

When adding new code, ask these questions:

### Question 1: What is the primary purpose?

**User Interface / Visual**
â†’ Place in **frontend/UI layer** (e.g., components, pages, layouts)

**API / Data Processing**
â†’ Place in **backend/application layer** (e.g., controllers, services)

**Business Rules / Domain Logic**
â†’ Place in **domain/business layer** (e.g., domain services, validators)

**External Integration**
â†’ Place in **infrastructure layer** (e.g., database, APIs, file storage)

**Reusable Utilities**
â†’ Place in **shared/common layer** (e.g., utilities, types, constants)

**Infrastructure / Deployment**
â†’ Place in **infrastructure/config layer** (e.g., IaC, deployment scripts)

**Documentation**
â†’ Place in **docs layer** (e.g., guides, ADRs, API specs)

### Question 2: Is this auto-generated code?

**YES** â†’ Place in designated generated code directory
- Never modify generated code
- Keep separate from custom code
- Regeneration should overwrite safely

**NO** â†’ Place in appropriate custom code directory

### Question 3: Is this shared across multiple parts of the application?

**YES** â†’ Place in shared/common layer
- Types shared between client and server
- Utility functions used everywhere
- Constants and configuration

**NO** â†’ Place close to where it's used (co-location)

---

## ğŸ“‚ Common Organizational Patterns

### Pattern 1: Monorepo with Workspaces

```
project/
â”œâ”€â”€ frontend/           # UI application
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/       # Pages/routes
â”‚   â”‚   â”œâ”€â”€ components/ # UI components
â”‚   â”‚   â””â”€â”€ lib/       # Frontend utilities
â”‚   â””â”€â”€ package.json
â”œâ”€â”€ backend/            # API application
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ modules/   # Feature modules
â”‚   â”‚   â”œâ”€â”€ common/    # Shared backend code
â”‚   â”‚   â””â”€â”€ main.ts
â”‚   â””â”€â”€ package.json
â”œâ”€â”€ shared/             # Code shared between frontend/backend
â”‚   â””â”€â”€ types/         # TypeScript types
â”œâ”€â”€ docs/              # Documentation
â””â”€â”€ package.json       # Workspace configuration
```

### Pattern 2: Feature-Based Organization

```
src/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ user.controller.ts
â”‚   â”‚   â”œâ”€â”€ user.service.ts
â”‚   â”‚   â”œâ”€â”€ user.entity.ts
â”‚   â”‚   â””â”€â”€ user.dto.ts
â”‚   â””â”€â”€ products/
â”‚       â”œâ”€â”€ product.controller.ts
â”‚       â”œâ”€â”€ product.service.ts
â”‚       â””â”€â”€ product.entity.ts
â”œâ”€â”€ common/            # Cross-feature shared code
â””â”€â”€ infrastructure/    # Technical infrastructure
```

### Pattern 3: Separation of Generated Code

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ generated/     # Auto-generated (DO NOT EDIT)
â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”œâ”€â”€ custom/        # Custom business logic
â”‚   â”‚   â””â”€â”€ services/
â”‚   â””â”€â”€ extensions/    # Extensions to generated code
â”‚       â””â”€â”€ user/
```

---

## ğŸš« Anti-Patterns to Avoid

### âŒ Mixing Layers
```
# Bad: Frontend and backend in same directory
src/
â”œâ”€â”€ Button.tsx         # Frontend component
â””â”€â”€ user.service.ts    # Backend service
```

### âŒ Editing Generated Code
```
# Bad: Modifying auto-generated files
src/generated/User.entity.ts  # DO NOT EDIT!
```

### âŒ Deep Nesting Without Purpose
```
# Bad: Unnecessary deep nesting
src/app/features/user/components/profile/edit/form/inputs/email/
```

### âŒ Unclear Naming
```
# Bad: Non-descriptive directory names
src/stuff/
src/things/
src/misc/
```

### âŒ Mixed Concerns
```
# Bad: Single file doing multiple things
src/utils.ts  # Contains: date formatting, API calls, validation, encryption
```

---

## âœ… Best Practices

### 1. Co-locate Related Code
Keep code close to where it's used:
```
components/
â””â”€â”€ Button/
    â”œâ”€â”€ Button.tsx
    â”œâ”€â”€ Button.test.tsx
    â”œâ”€â”€ Button.stories.tsx
    â””â”€â”€ index.ts
```

### 2. Use Index Files for Clean Exports
```typescript
// components/index.ts
export { Button } from './Button';
export { Input } from './Input';
export { Form } from './Form';

// Usage
import { Button, Input, Form } from '@/components';
```

### 3. Separate Configuration
```
config/
â”œâ”€â”€ database.config.ts
â”œâ”€â”€ auth.config.ts
â””â”€â”€ env.config.ts
```

### 4. Group Tests with Source
```
src/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ user.service.ts
â”‚   â””â”€â”€ user.service.test.ts
```

### 5. Use Clear Naming Conventions
- `*.test.ts` - Unit tests
- `*.spec.ts` - Integration tests
- `*.e2e.ts` - End-to-end tests
- `*.config.ts` - Configuration files
- `*.dto.ts` - Data transfer objects
- `*.entity.ts` - Database entities
- `*.interface.ts` - TypeScript interfaces

---

## ğŸ¤– AI Agent Instructions

When generating or modifying code:

1. **Inspect the existing structure first**
   - Run `ls -la` or similar to understand current organization
   - Look for existing patterns (feature-based, layer-based, etc.)
   - Identify where similar code already exists

2. **Follow established patterns**
   - If frontend code is in `client/src/`, put new frontend code there
   - If components use co-location pattern, follow it
   - Match existing naming conventions

3. **Respect layer boundaries**
   - Don't import backend code into frontend
   - Don't mix infrastructure code with business logic
   - Keep shared code truly shared (no app-specific logic)

4. **Never modify generated code**
   - Identify generated code directories
   - Use extension/override patterns instead
   - Document custom code clearly

5. **When uncertain, ask**
   - Pause and request clarification
   - Suggest options with trade-offs
   - Don't guess or make up new patterns

6. **Document your decisions**
   - Add comments explaining non-obvious placement
   - Update relevant documentation
   - Note architectural decisions

---

## ğŸ“š Related Documentation

- **Layer Architecture:** See `contribution-standards.mdc` for layer-specific standards
- **Security:** See `security-standards.mdc` for secure code organization
- **Testing:** See `testing-guide.mdc` for test file organization
- **Development:** See `local-development.mdc` for project setup

---

**Version:** 2.0
**Last Updated:** 2025-01-11
**Status:** Production-ready, project-agnostic guidelines

