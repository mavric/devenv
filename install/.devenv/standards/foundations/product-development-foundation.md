# Product Development Foundation

> Complete guide for building production-ready SaaS products from scratch

---

## Overview

This guide provides prescriptive, step-by-step instructions for building a SaaS product using Mavric's standard tech stack. It covers everything from idea validation to production deployment.

**Target Audience:** Developers building SaaS products with Apso + Next.js
**Time to MVP:** 8-12 weeks following this guide
**Prerequisite Knowledge:** TypeScript, React basics, REST APIs

---

## Table of Contents

1. [Phase 0: Planning & Architecture](#phase-0-planning--architecture)
2. [Phase 1: Foundation (Week 1-2)](#phase-1-foundation-week-1-2)
3. [Phase 2: Core Features (Week 3-6)](#phase-2-core-features-week-3-6)
4. [Phase 3: User Features (Week 7-9)](#phase-3-user-features-week-7-9)
5. [Phase 4: Polish & Launch (Week 10-12)](#phase-4-polish--launch-week-10-12)
6. [Development Workflow](#development-workflow)
7. [Architecture Principles](#architecture-principles)
8. [Testing Strategy](#testing-strategy)
9. [Deployment Strategy](#deployment-strategy)
10. [Maintenance & Scaling](#maintenance--scaling)

---

## Phase 0: Planning & Architecture

**Duration:** 3-5 days
**Goal:** Define requirements, design data model, plan architecture

### Step 1: Product Requirements

Create a product requirements document answering:

**Core Questions:**
- What problem does this solve?
- Who are the users? (personas)
- What are the must-have features for MVP?
- What can wait for v2/v3?
- What's the business model?

**Example Template:**

```markdown
# Product: [Name]

## Problem Statement
[2-3 sentences describing the problem]

## Target Users
- **Persona 1:** [Description, pain points, goals]
- **Persona 2:** [Description, pain points, goals]

## MVP Features (Must-Have)
1. Feature 1 - [Why it's critical]
2. Feature 2 - [Why it's critical]
3. Feature 3 - [Why it's critical]

## Post-MVP Features (Nice-to-Have)
1. Feature 4 - [Why it can wait]
2. Feature 5 - [Why it can wait]

## Success Metrics
- Metric 1: [Target]
- Metric 2: [Target]

## Revenue Model
- [How will this make money?]
```

**Output:** `features/docs/product-requirements.md`

---

### Step 2: Data Model Design

Design your database schema before writing any code.

**Process:**

1. **List Core Entities**
   - What are the main "things" in your system?
   - Example: User, Organization, Project, Task, Comment

2. **Define Relationships**
   - How do entities relate?
   - Example: Organization → User (one-to-many)

3. **Add Fields**
   - What properties does each entity need?
   - Start minimal, add fields as needed

4. **Consider Multi-Tenancy**
   - Will you have multiple customers?
   - Every entity should belong to an Organization

**Template:**

```
Entities:
- Organization (tenant)
- User (belongs to Organization)
- [Your Core Entity 1] (belongs to Organization)
- [Your Core Entity 2] (belongs to [Entity 1])

Relationships:
- Organization has many Users
- Organization has many [Entity 1]
- [Entity 1] has many [Entity 2]
```

**Use the SaaS Base Template:**

Start with these standard entities (see `SAAS_BASE_TEMPLATE.md`):
- ✅ Organization (multi-tenancy)
- ✅ User (authentication)
- ✅ Invitation (team invites)
- ✅ Subscription (billing)
- ✅ AuditLog (compliance)
- ✅ File (uploads)
- ✅ Notification (alerts)

Then add your product-specific entities.

**Output:** Draft `.apsorc` schema file

---

### Step 3: Architecture Design

**System Components:**

```
┌─────────────────────────────────────────────────┐
│                   Frontend                       │
│              Next.js + Tailwind                  │
│           shadcn/ui + React Hook Form            │
└───────────────────┬─────────────────────────────┘
                    │ REST API
┌───────────────────▼─────────────────────────────┐
│                   Backend                        │
│         NestJS (generated by Apso)               │
│           TypeORM + PostgreSQL                   │
└───────────────────┬─────────────────────────────┘
                    │
┌───────────────────▼─────────────────────────────┐
│              Infrastructure                      │
│   AWS (RDS, Lambda/ECS, S3, CloudWatch)          │
│        Stripe (payments) + Resend (email)        │
└─────────────────────────────────────────────────┘
```

**Key Decisions:**

| Decision | Choice | Why |
|----------|--------|-----|
| Backend Framework | NestJS (via Apso) | Auto-generated, scalable, TypeScript |
| Database | PostgreSQL | Relational, ACID, JSON support |
| Frontend Framework | Next.js 14+ | SSR, SEO, modern DX |
| UI Library | shadcn/ui + Tailwind | Fast, customizable, accessible |
| Auth | Better Auth | Modern, lightweight, Apso-compatible |
| Payments | Stripe | Industry standard, comprehensive |
| Email | Resend | Best deliverability, simple API |
| File Storage | AWS S3 | Scalable, durable, cheap |
| Hosting | Vercel (frontend) + AWS (backend) | Auto-deploy, global CDN |

**Output:** Architecture diagram (can be Markdown or diagram tool)

---

### Step 4: Project Structure

**Standard Monorepo Structure:**

```
product-name/
├── client/              # Next.js frontend
│   ├── src/
│   │   ├── app/         # Next.js App Router pages
│   │   ├── components/  # React components
│   │   │   ├── ui/      # shadcn components
│   │   │   └── features/ # Feature-specific components
│   │   ├── lib/         # Utilities & API clients
│   │   └── types/       # TypeScript types
│   ├── public/          # Static assets
│   └── package.json
│
├── server/              # NestJS backend (generated by Apso)
│   ├── src/
│   │   ├── autogen/     # ⚠️ NEVER MODIFY - Generated code
│   │   ├── extensions/  # ✅ Custom code here
│   │   ├── common/      # Shared utilities
│   │   └── main.ts
│   ├── test/
│   └── package.json
│
├── shared/              # Shared TypeScript types
│   ├── types/
│   └── package.json
│
├── context/             # Documentation & guides
│   ├── README.md
│   ├── schema.json      # Apso schema
│   └── *.md             # Design docs
│
├── docs/                # Product documentation
│   ├── product-requirements.md
│   └── architecture.md
│
├── package.json         # Root workspace config
└── README.md
```

**Output:** Create directory structure

---

## Phase 1: Foundation (Week 1-2)

**Goal:** Set up infrastructure, generate backend, implement authentication

### Week 1: Backend Setup

#### Day 1: Generate Backend with Apso

```bash
# 1. Install Apso CLI
npm install -g @apso/apso-cli

# 2. Create backend project
apso server new --name product-backend
cd product-backend

# 3. Define schema in .apsorc
# Start with base SaaS template + your core entities

# 4. Generate code
apso server scaffold

# 5. Install dependencies
npm install

# 6. Start local database
npm run compose

# 7. Provision database
npm run provision

# 8. Verify server starts
npm run start:dev
```

**Verify:**
- ✅ Server runs at http://localhost:3001
- ✅ OpenAPI docs at http://localhost:3001/api/docs
- ✅ All entities have CRUD endpoints
- ✅ Database has all tables

---

#### Day 2: Set Up Next.js Frontend

```bash
# 1. Create Next.js app
cd ..
npx create-next-app@latest client --typescript --tailwind --app

# 2. Install core dependencies
cd client
npm install axios zod react-hook-form @tanstack/react-query

# 3. Initialize shadcn/ui
npx shadcn-ui@latest init

# 4. Install first components
npx shadcn-ui@latest add button
npx shadcn-ui@latest add input
npx shadcn-ui@latest add form
npx shadcn-ui@latest add card
npx shadcn-ui@latest add dialog
npx shadcn-ui@latest add dropdown-menu
npx shadcn-ui@latest add toast

# 5. Configure environment
cp .env.example .env.local
# Add: NEXT_PUBLIC_API_URL=http://localhost:3001
```

**Create Base Structure:**

```typescript
// src/lib/api-client.ts
import axios from 'axios';

export const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001',
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add auth token interceptor
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('auth_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

---

#### Day 3-4: Implement Authentication

**Backend (Better Auth Integration):**

```bash
cd ../server
npm install better-auth
```

Create auth service in extensions:

```typescript
// server/src/extensions/auth/auth.service.ts
import { Injectable } from '@nestjs/common';
import { betterAuth } from 'better-auth';

@Injectable()
export class AuthService {
  private auth = betterAuth({
    database: {
      // Point to your PostgreSQL connection
      type: 'postgres',
      url: process.env.DATABASE_URL,
    },
    emailAndPassword: {
      enabled: true,
    },
  });

  async signUp(email: string, password: string, name: string) {
    return this.auth.api.signUp.email({ email, password, name });
  }

  async signIn(email: string, password: string) {
    return this.auth.api.signIn.email({ email, password });
  }

  async verifyToken(token: string) {
    return this.auth.api.session.verify({ token });
  }
}
```

**Frontend (Auth Flow):**

```typescript
// client/src/lib/auth.ts
import { apiClient } from './api-client';

export async function signUp(email: string, password: string, name: string) {
  const res = await apiClient.post('/auth/signup', { email, password, name });
  localStorage.setItem('auth_token', res.data.token);
  return res.data;
}

export async function signIn(email: string, password: string) {
  const res = await apiClient.post('/auth/signin', { email, password });
  localStorage.setItem('auth_token', res.data.token);
  return res.data;
}

export async function signOut() {
  localStorage.removeItem('auth_token');
  window.location.href = '/login';
}

export function getToken() {
  return localStorage.getItem('auth_token');
}
```

Create auth pages:

```typescript
// client/src/app/login/page.tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { signIn } from '@/lib/auth';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

export default function LoginPage() {
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await signIn(email, password);
      router.push('/dashboard');
    } catch (error) {
      console.error('Login failed:', error);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center">
      <form onSubmit={handleSubmit} className="w-full max-w-md space-y-4">
        <h1 className="text-2xl font-bold">Log In</h1>
        <Input
          type="email"
          placeholder="Email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <Input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <Button type="submit" className="w-full">
          Log In
        </Button>
      </form>
    </div>
  );
}
```

**Verify:**
- ✅ User can sign up
- ✅ User can log in
- ✅ Token is stored
- ✅ Protected routes redirect to login

---

#### Day 5: Multi-Tenancy Setup

**Backend Organization Middleware:**

```typescript
// server/src/extensions/common/organization.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class OrganizationMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // Extract org ID from user session
    const user = req['user'];
    if (user) {
      req['organizationId'] = user.organizationId;
    }
    next();
  }
}
```

**Apply to All Routes:**

```typescript
// server/src/app.module.ts
export class AppModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(OrganizationMiddleware)
      .forRoutes('*');
  }
}
```

**Auto-Filter Queries:**

```typescript
// server/src/extensions/common/org-scoped.decorator.ts
export function OrgScoped() {
  return applyDecorators(
    UseInterceptors(OrgScopedInterceptor)
  );
}

// Apply to all controllers
@Controller('projects')
@OrgScoped()
export class ProjectController {
  // All queries automatically filtered by organizationId
}
```

---

### Week 2: Core Infrastructure

#### Day 1: Set Up Stripe Billing

```bash
# Backend
cd server
npm install stripe

# Frontend
cd ../client
npm install @stripe/stripe-js @stripe/react-stripe-js
```

**Backend Stripe Service:**

```typescript
// server/src/extensions/billing/stripe.service.ts
import { Injectable } from '@nestjs/common';
import Stripe from 'stripe';

@Injectable()
export class StripeService {
  private stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
    apiVersion: '2023-10-16',
  });

  async createCustomer(email: string, name: string) {
    return this.stripe.customers.create({ email, name });
  }

  async createCheckoutSession(customerId: string, priceId: string) {
    return this.stripe.checkout.sessions.create({
      customer: customerId,
      mode: 'subscription',
      line_items: [{ price: priceId, quantity: 1 }],
      success_url: `${process.env.FRONTEND_URL}/billing/success`,
      cancel_url: `${process.env.FRONTEND_URL}/billing/cancel`,
    });
  }

  async handleWebhook(event: Stripe.Event) {
    switch (event.type) {
      case 'customer.subscription.created':
        // Update subscription in database
        break;
      case 'customer.subscription.updated':
        // Update subscription status
        break;
      case 'customer.subscription.deleted':
        // Mark subscription as canceled
        break;
    }
  }
}
```

---

#### Day 2: File Uploads (S3)

```bash
cd server
npm install @aws-sdk/client-s3 @aws-sdk/s3-request-presigner multer
```

**Backend S3 Service:**

```typescript
// server/src/extensions/files/s3.service.ts
import { Injectable } from '@nestjs/common';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

@Injectable()
export class S3Service {
  private s3 = new S3Client({
    region: process.env.AWS_S3_REGION,
    credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    },
  });

  async uploadFile(file: Express.Multer.File, organizationId: number) {
    const key = `${organizationId}/${Date.now()}-${file.originalname}`;

    await this.s3.send(new PutObjectCommand({
      Bucket: process.env.AWS_S3_BUCKET,
      Key: key,
      Body: file.buffer,
      ContentType: file.mimetype,
    }));

    return {
      key,
      url: `https://${process.env.AWS_S3_BUCKET}.s3.amazonaws.com/${key}`,
    };
  }

  async getPresignedUrl(key: string, expiresIn = 3600) {
    return getSignedUrl(this.s3, new GetObjectCommand({
      Bucket: process.env.AWS_S3_BUCKET,
      Key: key,
    }), { expiresIn });
  }
}
```

---

#### Day 3: Email Integration (Resend)

```bash
cd server
npm install resend
```

**Backend Email Service:**

```typescript
// server/src/extensions/email/resend.service.ts
import { Injectable } from '@nestjs/common';
import { Resend } from 'resend';

@Injectable()
export class EmailService {
  private resend = new Resend(process.env.RESEND_API_KEY);

  async sendWelcomeEmail(to: string, name: string) {
    return this.resend.emails.send({
      from: 'noreply@yourapp.com',
      to,
      subject: 'Welcome to [Your Product]!',
      html: `<h1>Welcome, ${name}!</h1><p>Thanks for signing up.</p>`,
    });
  }

  async sendPasswordReset(to: string, resetToken: string) {
    const resetUrl = `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`;
    return this.resend.emails.send({
      from: 'noreply@yourapp.com',
      to,
      subject: 'Reset Your Password',
      html: `<a href="${resetUrl}">Click here to reset your password</a>`,
    });
  }
}
```

---

#### Day 4-5: Audit Logging

**Backend Audit Interceptor:**

```typescript
// server/src/extensions/common/audit.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { tap } from 'rxjs/operators';

@Injectable()
export class AuditInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler) {
    const req = context.switchToHttp().getRequest();
    const user = req.user;
    const orgId = req.organizationId;

    return next.handle().pipe(
      tap(async (data) => {
        // Log to AuditLog table
        await this.auditLogService.create({
          organizationId: orgId,
          userId: user?.id,
          action: `${req.method} ${req.url}`,
          resource_type: context.getClass().name,
          resource_id: data?.id,
          ip_address: req.ip,
          user_agent: req.headers['user-agent'],
        });
      }),
    );
  }
}
```

---

## Phase 2: Core Features (Week 3-6)

**Goal:** Implement your product's unique value proposition

### Week 3: Core Entity CRUD

For each core entity in your product:

#### Day 1: Design UI Components

```typescript
// Example: Project entity

// client/src/components/features/projects/project-card.tsx
export function ProjectCard({ project }: { project: Project }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{project.name}</CardTitle>
        <CardDescription>{project.description}</CardDescription>
      </CardHeader>
      <CardContent>
        <p>Status: {project.status}</p>
        <p>Created: {new Date(project.created_at).toLocaleDateString()}</p>
      </CardContent>
      <CardFooter>
        <Button>Edit</Button>
        <Button variant="destructive">Delete</Button>
      </CardFooter>
    </Card>
  );
}
```

#### Day 2: Implement List View

```typescript
// client/src/app/projects/page.tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { ProjectCard } from '@/components/features/projects/project-card';

export default function ProjectsPage() {
  const { data: projects, isLoading } = useQuery({
    queryKey: ['projects'],
    queryFn: async () => {
      const res = await apiClient.get('/projects');
      return res.data;
    },
  });

  if (isLoading) return <div>Loading...</div>;

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {projects.map((project) => (
        <ProjectCard key={project.id} project={project} />
      ))}
    </div>
  );
}
```

#### Day 3: Implement Create Form

```typescript
// client/src/app/projects/new/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useMutation } from '@tanstack/react-query';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { apiClient } from '@/lib/api-client';

const projectSchema = z.object({
  name: z.string().min(3, 'Name must be at least 3 characters'),
  description: z.string().optional(),
});

export default function NewProjectPage() {
  const router = useRouter();
  const form = useForm({
    resolver: zodResolver(projectSchema),
  });

  const createMutation = useMutation({
    mutationFn: async (data: z.infer<typeof projectSchema>) => {
      const res = await apiClient.post('/projects', data);
      return res.data;
    },
    onSuccess: () => {
      router.push('/projects');
    },
  });

  return (
    <form onSubmit={form.handleSubmit((data) => createMutation.mutate(data))}>
      {/* Form fields */}
    </form>
  );
}
```

#### Day 4: Implement Edit/Delete

```typescript
// client/src/app/projects/[id]/edit/page.tsx
export default function EditProjectPage({ params }: { params: { id: string } }) {
  // Similar to create, but pre-populate form with existing data
  // Use PATCH request instead of POST
}
```

#### Day 5: Add Custom Endpoints

```typescript
// Example: Add custom business logic beyond CRUD

// server/src/extensions/Project/Project.controller.ts
@Controller('projects')
export class ProjectController {
  @Post(':id/archive')
  async archive(@Param('id') id: number) {
    // Custom logic to archive project
    return this.projectService.archive(id);
  }

  @Get(':id/statistics')
  async getStatistics(@Param('id') id: number) {
    // Custom aggregation logic
    return this.projectService.getStatistics(id);
  }
}
```

**Repeat for Each Core Entity** (Week 4-6)

---

## Phase 3: User Features (Week 7-9)

### Week 7: Team Collaboration

#### Invite System

**Backend:**
```typescript
// server/src/extensions/Invitation/Invitation.service.ts
async createInvitation(email: string, role: string, orgId: number) {
  const token = crypto.randomBytes(32).toString('hex');
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

  const invitation = await this.invitationRepository.save({
    email,
    role,
    token,
    organizationId: orgId,
    status: 'pending',
    expires_at: expiresAt,
  });

  // Send invitation email
  await this.emailService.sendInvitation(email, token);

  return invitation;
}
```

---

### Week 8: Notifications

**Real-Time Notifications (Optional):**

```bash
# If you need real-time updates
npm install socket.io socket.io-client
```

**Backend WebSocket:**
```typescript
// server/src/extensions/notifications/notifications.gateway.ts
@WebSocketGateway()
export class NotificationsGateway {
  @WebSocketServer()
  server: Server;

  sendNotificationToUser(userId: number, notification: Notification) {
    this.server.to(`user:${userId}`).emit('notification', notification);
  }
}
```

---

### Week 9: Settings & Preferences

- User profile editing
- Organization settings
- Notification preferences
- Theme preferences (dark mode)
- Email preferences

---

## Phase 4: Polish & Launch (Week 10-12)

### Week 10: Testing & Bug Fixes

#### Backend Tests

```typescript
// server/test/project.e2e-spec.ts
describe('ProjectController (e2e)', () => {
  it('/projects (GET)', () => {
    return request(app.getHttpServer())
      .get('/projects')
      .expect(200)
      .expect((res) => {
        expect(res.body).toBeInstanceOf(Array);
      });
  });

  it('/projects (POST)', () => {
    return request(app.getHttpServer())
      .post('/projects')
      .send({ name: 'Test Project' })
      .expect(201);
  });
});
```

#### Frontend Tests

```typescript
// client/src/__tests__/project-card.test.tsx
import { render, screen } from '@testing-library/react';
import { ProjectCard } from '@/components/features/projects/project-card';

describe('ProjectCard', () => {
  it('renders project name', () => {
    render(<ProjectCard project={{ id: 1, name: 'Test' }} />);
    expect(screen.getByText('Test')).toBeInTheDocument();
  });
});
```

---

### Week 11: Performance Optimization

**Backend:**
- Add database indexes
- Implement caching (Redis)
- Optimize N+1 queries
- Add pagination

**Frontend:**
- Image optimization (Next.js Image)
- Code splitting
- Lazy loading
- React Query caching

---

### Week 12: Deployment & Launch

#### Deploy Backend

```bash
# Deploy to AWS via Apso
apso deploy --env production
```

#### Deploy Frontend

```bash
# Deploy to Vercel
cd client
vercel --prod
```

#### Post-Launch Checklist

- ✅ Set up monitoring (Sentry)
- ✅ Configure backup strategy
- ✅ Set up alerts (CloudWatch)
- ✅ Enable HTTPS
- ✅ Configure DNS
- ✅ Set up status page
- ✅ Create support email
- ✅ Set up analytics (PostHog)

---

## Development Workflow

### Daily Workflow

```bash
# Morning routine
git pull origin main
npm install  # Update dependencies

# Start development
npm run dev:all  # Start both client and server

# Make changes
# Test changes
# Commit frequently

# End of day
git add .
git commit -m "feat: add project filtering"
git push origin feature/project-filtering
```

---

### Git Strategy

**Branch Naming:**
- `feature/[feature-name]` - New features
- `fix/[bug-name]` - Bug fixes
- `refactor/[area]` - Code refactoring
- `docs/[section]` - Documentation updates

**Commit Messages:**
```
feat: add user profile editing
fix: resolve login redirect loop
refactor: extract auth logic to hook
docs: update API documentation
```

---

### Code Review Checklist

Before merging:
- ✅ All tests pass
- ✅ No console errors
- ✅ Code follows style guide
- ✅ New features have tests
- ✅ Breaking changes documented
- ✅ Database migrations created
- ✅ Environment variables documented

---

## Architecture Principles

### 1. Separation of Concerns

**Backend:**
- Controllers handle HTTP (thin layer)
- Services contain business logic
- Repositories handle data access
- DTOs define API contracts

**Frontend:**
- Components handle presentation
- Hooks handle state/logic
- Services handle API calls
- Types define data contracts

---

### 2. DRY (Don't Repeat Yourself)

**Extract Common Patterns:**

```typescript
// Instead of repeating API calls
// ❌ BAD
const res1 = await fetch('/api/projects', { headers: { 'Authorization': token }});
const res2 = await fetch('/api/tasks', { headers: { 'Authorization': token }});

// ✅ GOOD
const apiClient = axios.create({
  baseURL: '/api',
  headers: { 'Authorization': token },
});
const res1 = await apiClient.get('/projects');
const res2 = await apiClient.get('/tasks');
```

---

### 3. Type Safety

**Share Types Between Client and Server:**

```typescript
// shared/types/project.ts
export interface Project {
  id: number;
  name: string;
  description: string | null;
  status: 'active' | 'archived';
  created_at: string;
  updated_at: string;
}

// Use in both client and server
import { Project } from '@shared/types/project';
```

---

### 4. Error Handling

**Backend:**
```typescript
// Use consistent error structure
throw new HttpException({
  statusCode: 400,
  message: 'Project name is required',
  error: 'Bad Request',
}, HttpStatus.BAD_REQUEST);
```

**Frontend:**
```typescript
// Handle errors gracefully
try {
  await createProject(data);
} catch (error) {
  if (error.response?.status === 400) {
    toast.error(error.response.data.message);
  } else {
    toast.error('Something went wrong. Please try again.');
  }
}
```

---

### 5. Security Best Practices

**Backend:**
- ✅ Validate all inputs
- ✅ Sanitize user data
- ✅ Use parameterized queries (TypeORM handles this)
- ✅ Implement rate limiting
- ✅ Enable CORS properly
- ✅ Use HTTPS in production
- ✅ Hash passwords (Better Auth handles this)
- ✅ Implement CSRF protection

**Frontend:**
- ✅ Never store secrets in code
- ✅ Sanitize user input in UI
- ✅ Validate forms before submission
- ✅ Use Content Security Policy
- ✅ Implement XSS protection

---

## Testing Strategy

### Test Pyramid

```
     /\
    /  \   E2E Tests (10%)
   /____\
  /      \  Integration Tests (20%)
 /________\
/          \ Unit Tests (70%)
```

### Unit Tests

**Test individual functions:**

```typescript
// server/src/extensions/Project/Project.service.spec.ts
describe('ProjectService', () => {
  it('should create a project', async () => {
    const project = await service.create({ name: 'Test' });
    expect(project.name).toBe('Test');
  });
});
```

### Integration Tests

**Test API endpoints:**

```typescript
// server/test/project.e2e-spec.ts
describe('Project API', () => {
  it('GET /projects returns all projects', async () => {
    const res = await request(app.getHttpServer())
      .get('/projects')
      .expect(200);
    expect(res.body).toBeInstanceOf(Array);
  });
});
```

### E2E Tests (Optional)

**Test full user workflows:**

```typescript
// client/e2e/create-project.spec.ts (using Playwright)
test('user can create a project', async ({ page }) => {
  await page.goto('/projects/new');
  await page.fill('input[name="name"]', 'Test Project');
  await page.click('button[type="submit"]');
  await expect(page).toHaveURL('/projects');
  await expect(page.locator('text=Test Project')).toBeVisible();
});
```

---

## Deployment Strategy

### Environments

**Local → Staging → Production**

| Environment | Purpose | Database | Frontend | Backend |
|-------------|---------|----------|----------|---------|
| Local | Development | Local PostgreSQL | localhost:3000 | localhost:3001 |
| Staging | Testing | AWS RDS (staging) | staging.vercel.app | AWS Lambda/ECS (staging) |
| Production | Live | AWS RDS (prod) | app.yourproduct.com | AWS Lambda/ECS (prod) |

---

### CI/CD Pipeline

**GitHub Actions Workflow:**

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Deploy backend
        run: |
          cd server
          npm install
          npm run build
          npm run deploy:production

  frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Deploy frontend
        run: |
          cd client
          npm install
          vercel --prod --token=${{ secrets.VERCEL_TOKEN }}
```

---

## Maintenance & Scaling

### Monitoring

**Set Up Alerts:**

```typescript
// server/src/main.ts
import * as Sentry from '@sentry/node';

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
});

// All errors automatically reported
```

**Key Metrics to Track:**
- Response time (p50, p95, p99)
- Error rate
- Database query time
- Memory usage
- Active users

---

### Database Maintenance

**Regular Tasks:**
- Weekly backups (automated)
- Monthly performance review
- Quarterly index optimization
- Annual data retention cleanup

---

### Scaling Checklist

**When to Scale:**

| Metric | Threshold | Action |
|--------|-----------|--------|
| Response time > 500ms | p95 | Add caching, optimize queries |
| CPU > 80% | Sustained | Increase server size |
| Memory > 80% | Sustained | Investigate memory leaks |
| Database connections > 80% | Any | Add connection pooling |
| Active users > 10,000 | Any | Consider load balancing |

---

## Quick Reference

### Essential Commands

```bash
# Backend (Apso)
apso server new --name <name>     # Create new project
apso server scaffold              # Generate code
npm run compose                   # Start database
npm run provision                 # Setup schema
npm run start:dev                 # Start dev server

# Frontend (Next.js)
npm run dev                       # Start dev server
npm run build                     # Build for production
npm run start                     # Start production server
npx shadcn-ui@latest add <comp>   # Add UI component

# Git
git checkout -b feature/<name>    # New feature branch
git add . && git commit -m "msg"  # Commit changes
git push origin <branch>          # Push to remote

# Deployment
vercel --prod                     # Deploy frontend
apso deploy --env production      # Deploy backend
```

---

### Common Issues & Solutions

**Issue:** "Cannot connect to database"
**Solution:** Ensure `npm run compose` has been run and PostgreSQL is running

**Issue:** "Module not found"
**Solution:** Run `npm install` in both client and server directories

**Issue:** "CORS error"
**Solution:** Configure CORS in backend to allow frontend origin

**Issue:** "Token expired"
**Solution:** Implement token refresh logic in auth service

---

## Summary

This guide provides a complete framework for building SaaS products. Key takeaways:

✅ **Start with schema design** - Get your data model right first
✅ **Use the tech stack** - Don't reinvent the wheel
✅ **Build incrementally** - MVP first, features later
✅ **Test continuously** - Catch bugs early
✅ **Deploy often** - Ship to production regularly
✅ **Monitor always** - Know when things break

**Timeline: 12 weeks to MVP**

- Weeks 1-2: Foundation (backend, auth, infrastructure)
- Weeks 3-6: Core features (your product's unique value)
- Weeks 7-9: User features (collaboration, settings)
- Weeks 10-12: Polish, testing, launch

---

**Version:** 1.0
**Last Updated:** 2025-01-11
**Status:** Production-ready guide

